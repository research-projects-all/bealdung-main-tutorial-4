      - name: Generate summary and fail if needed
        if: always()
        shell: bash
        run: |
          echo "=============================================="
          echo "ðŸ” Semgrep security summary"
          echo "=============================================="

          # ---------- 1.  CUSTOM  RULES  (ERROR only) ----------
          if [ -s custom.txt ]; then
            echo "âŒ CUSTOM RULES â€“ VULNERABILITIES FOUND:"
            cat custom.txt
            echo ""
          else
            echo "âœ… CUSTOM RULES â€“ PASSED (no ERROR findings)"
          fi

          echo "----------------------------------------------"

          # ---------- 2.  POSITIVE  COVERAGE  (ERROR vs WARNING) ----------
          echo "ðŸ”Ž Secure-by-default coverage (beginner positive rules):"

          # split positive.txt into ERROR and WARNING lines
          grep -E 'severity:(ERROR|error)' positive.txt > positive-ERROR.txt || true
          grep -E 'severity:(WARNING|warning|INFO|info)' positive.txt > positive-WARN.txt || true

          # coverage counter still uses WARNING-level hits (internal)
          python - << 'EOF'
          import json, re
          from pathlib import Path

          expected = {
              "semgrep.POS-escape-path-var",
              "semgrep.POS-request-mapping-method",
              "semgrep.POS-csrf-enabled",
              "semgrep.POS-cookie-flags",
              "semgrep.POS-no-hard-secret",
              "semgrep.POS-admin-authz",
              "semgrep.POS-idor-ownership",
          }

          try:
              data = json.load(open("positive.json", encoding="utf-8"))
              results = {r.get("check_id") for r in data.get("results", [])}
          except Exception:
              results = set()

          matched = expected & results
          missing = sorted(expected - matched)

          Path("positive-coverage.txt").write_text(
              f"{len(matched)}/{len(expected)} positive (secure-by-default) rules matched\n",
              encoding="utf-8",
          )
          Path("positive-missing.txt").write_text("\n".join(missing) + "\n" if missing else "")
          EOF

          cat positive-coverage.txt

          # list **missing** positive rules (ERROR level)
          if [ -s positive-missing.txt ]; then
            echo ""
            echo "âŒ SECURE-BY-DEFAULT â€“ FAILED"
            echo "The following positive rules had NO matches in this tutorial:"
            cat positive-missing.txt
            echo ""
          else
            echo ""
            echo "âœ… SECURE-BY-DEFAULT â€“ PASSED"
            echo "All 7 beginner positive rules are present at least once."
          fi

          # ---------- 3.  WARNINGS  (do **not** fail the job) ----------
          if [ -s positive-WARN.txt ]; then
            echo ""
            echo "âš ï¸  WARNINGS â€“ best-practice hints (no fail):"
            cat positive-WARN.txt
            echo ""
          fi

          echo "=============================================="

          # ---------- 4.  PASS / FAIL  DECISION ----------
          # fail only on **ERRORS** (custom **or** missing positive)
          FAIL=0
          [ -s custom.txt ]        && FAIL=1
          [ -s positive-missing.txt ] && FAIL=1

          if [ "$FAIL" -ne 0 ]; then
            echo "ðŸ’¥ BUILD FAILED â€“ tutorial is not secure (vulnerabilities and/or not secure-by-default)."
            exit 1
          else
            echo "ðŸŽ‰ BUILD PASSED â€“ no vulnerabilities and secure-by-default (all positive patterns present)."
          fi