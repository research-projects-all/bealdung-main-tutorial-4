rules:
  # 1. Returning user-controlled parameter directly (XSS risk)
  - id: POS-escape-path-var
    pattern-either:
      - pattern: |
          @GetMapping("...")
          public String $METHOD(@PathVariable String $X) {
            ...
            return $X;
          }
      - pattern: |
          @GetMapping("...")
          public String $METHOD(@RequestParam String $X) {
            ...
            return $X;
          }
    message: |
      ðŸ”’  **Beginner safety**: returning a user-controlled parameter directly from a
      controller method can cause **XSS**. Escape the value before returning it
      (for example with `HtmlUtils.htmlEscape(..)`).
    severity: ERROR
    languages: [java]
    fix: |
      return HtmlUtils.htmlEscape($X);

  # 2. Prefer method-specific mappings (@GetMapping/@PostMapping)
  - id: POS-request-mapping-method
    pattern: |
      @RequestMapping("...")
    message: |
      ðŸ”’  **Beginner safety**: prefer method-specific mappings like `@GetMapping`,
      `@PostMapping`, `@PutMapping`, etc. instead of bare `@RequestMapping` for
      REST endpoints in tutorials.
    severity: ERROR
    languages: [java]
    fix: |
      @GetMapping("...")

  # 3. CSRF should not be globally disabled
  - id: POS-csrf-enabled
    pattern: |
      $CFG.csrf().disable();
    message: |
      ðŸ”’  **Beginner safety**: avoid calling `.csrf().disable()` in starter Spring
      Security configuration. Keeping CSRF enabled is safer for browser-based apps.
      If you are building a stateless API with tokens and understand the trade-offs,
      document it (e.g., `// stateless API`) and justify with `# nosemgrep`.
    severity: ERROR
    languages: [java]

  # 4. Cookies must set HttpOnly and Secure flags
  - id: POS-cookie-flags
    pattern: |
      new Cookie(...);
    message: |
      ðŸ”’  **Beginner safety**: cookies that carry sensitive data should set both
      `HttpOnly` and `Secure` flags. At beginner level, always show these flags
      in examples.
    severity: ERROR
    languages: [java]
    fix-regex:
      regex: 'new Cookie\(([^)]*)\)'
      replacement: 'new Cookie($1); cookie.setHttpOnly(true); cookie.setSecure(true);'

  # 5. No hard-coded secrets in config files
  - id: POS-no-hard-secret
    pattern-regex: '^(api\.key|db\.password|jwt\.secret)\s*=.+'
    message: |
      ðŸ”’  **Beginner safety**: avoid hard-coded secrets in `.properties` / `.yml`
      files in tutorials (API keys, DB passwords, JWT secrets). Show how to load
      them from environment variables, secret managers, or a vault.
    severity: ERROR
    languages: [generic]
    paths:
      include:
        - "*.properties"
        - "*.yml"
        - "*.yaml"

  # 6. Admin endpoint must have @PreAuthorize
  - id: POS-admin-authz
    pattern: |
      @GetMapping($P)
      public $RET $METHOD(..) {
        ...
      }
    metavariable-regex:
      metavariable: $P
      regex: ^"/admin/.*"
    message: |
      ðŸ”’  **Beginner safety**: admin endpoints should use method-level authorization,
      e.g. `@PreAuthorize("hasRole('ADMIN')")`. Tutorials should always model this
      practice on `/admin/**` routes.
    severity: ERROR
    languages: [java]

  # 7. findById must check ownership (IDOR guard)
  - id: POS-idor-ownership
    pattern: |
      $RET = $REPO.findById($ID);
    message: |
      ðŸ”’  **Beginner safety**: when loading by ID (e.g., `findById`), tutorials
      should check that the **current user** owns or is allowed to access `$ID`
      before returning `$RET`.

      Example pattern to model:

      ```java
      var current = currentUser();
      if (!current.getId().equals($ID)) {
          throw new AccessDeniedException("Forbidden");
      }
      ```
    severity: ERROR
    languages: [java]
