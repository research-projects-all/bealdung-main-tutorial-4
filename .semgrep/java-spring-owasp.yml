rules:
  # ============================================================
  # OWASP-aligned Spring rules (tuned to reduce false positives)
  #
  # Key idea:
  # - Use taint mode where possible so we only flag flows from
  #   request-derived sources -> dangerous sinks.
  #
  # OWASP refs (high level):
  # - Injection Prevention in Java (SQL/JPA/OS/XPath) and XSS, Log Injection:
  #   OWASP Java Security Cheat Sheet.
  # - Mass Assignment: OWASP Mass Assignment Cheat Sheet.
  # - Bean Validation: OWASP Bean Validation Cheat Sheet.
  # ============================================================

  # ------------------------------------------------------------
  # A) SQL Injection (JDBC): request data -> Statement.execute*(String)
  # OWASP: use query parameterization / PreparedStatement instead of building SQL strings.
  # This flags only when request-derived data can reach Statement.executeQuery/executeUpdate/execute.
  # ------------------------------------------------------------
  - id: SPRING-OWASP-SQLI-JDBC-STATEMENT
    message: >
      Possible SQL injection: request-derived data reaches JDBC Statement.execute*(String).
      Prefer PreparedStatement with parameter placeholders (?), not string-built SQL.
    severity: ERROR
    languages: [java]
    mode: taint
    metadata:
      category: security
      cwe: "CWE-89"
      owasp: "A03:2021 Injection"
      confidence: high
      framework: [spring, spring-mvc, spring-boot]
    paths:
      include:
        - "**/*.java"
      exclude:
        - "**/test/**"
        - "**/*Test.java"
        - ".semgrep/**"
    pattern-sources:
      # Spring MVC / Spring Web common sources
      - pattern: $REQ.getParameter(...)
      - pattern: $REQ.getHeader(...)
      - pattern: $REQ.getQueryString()
      - pattern: $REQ.getCookies()
      - pattern: $REQ.getPathInfo()
      # Annotations (best-effort): treat directly-read params as sources when assigned
      - pattern: |
          @RequestParam(...) $T $X
      - pattern: |
          @PathVariable(...) $T $X
    pattern-sinks:
      - pattern: $STMT.executeQuery($SQL)
      - pattern: $STMT.executeUpdate($SQL)
      - pattern: $STMT.execute($SQL)
    pattern-sanitizers:
      # If you already use placeholders with PreparedStatement, this rule won't trigger.
      # (We also treat simple allowlist validation as a sanitizer to reduce noise.)
      - pattern: java.util.regex.Pattern.matches($RE, $X)

  # ------------------------------------------------------------
  # B) SQL Injection (JPA): request data -> entityManager.createQuery/createNativeQuery(String)
  # OWASP: use parameterized JPQL (named params) rather than concatenated query strings.
  # ------------------------------------------------------------
  - id: SPRING-OWASP-SQLI-JPA-QUERYSTRING
    message: >
      Possible injection: request-derived data reaches JPA createQuery/createNativeQuery with a dynamic query string.
      Prefer parameterized JPQL/Criteria API (e.g., :namedParam) instead of string concatenation.
    severity: ERROR
    languages: [java]
    mode: taint
    metadata:
      category: security
      cwe: "CWE-89"
      owasp: "A03:2021 Injection"
      confidence: high
      framework: [spring, jpa]
    paths:
      include: ["**/*.java"]
      exclude: ["**/test/**", "**/*Test.java", ".semgrep/**"]
    pattern-sources:
      - pattern: $REQ.getParameter(...)
      - pattern: $REQ.getHeader(...)
      - pattern: |
          @RequestParam(...) $T $X
      - pattern: |
          @PathVariable(...) $T $X
    pattern-sinks:
      - pattern: $EM.createQuery($Q)
      - pattern: $EM.createNativeQuery($Q)
      - pattern: $EM.createNamedQuery($Q)
    pattern-sanitizers:
      - pattern: java.util.regex.Pattern.matches($RE, $X)

  # ------------------------------------------------------------
  # C) OS Command Injection: request data -> Runtime.exec / ProcessBuilder
  # OWASP: use stack APIs instead of building OS commands.
  # ------------------------------------------------------------
  - id: SPRING-OWASP-CMDI-EXEC
    message: >
      Possible OS command injection: request-derived data reaches Runtime.exec / ProcessBuilder.
      Prefer safe platform APIs (or strict allowlist validation + fixed command mapping).
    severity: ERROR
    languages: [java]
    mode: taint
    metadata:
      category: security
      cwe: "CWE-78"
      owasp: "A03:2021 Injection"
      confidence: high
      framework: [spring]
    paths:
      include: ["**/*.java"]
      exclude: ["**/test/**", "**/*Test.java", ".semgrep/**"]
    pattern-sources:
      - pattern: $REQ.getParameter(...)
      - pattern: $REQ.getHeader(...)
      - pattern: |
          @RequestParam(...) $T $X
      - pattern: |
          @PathVariable(...) $T $X
    pattern-sinks:
      - pattern: java.lang.Runtime.getRuntime().exec($CMD)
      - pattern: (new ProcessBuilder($CMD, ...)).start()
      - pattern: (new ProcessBuilder($LIST)).start()
    pattern-sanitizers:
      # Allowlist validation reduces FP (still review carefully)
      - pattern: java.util.regex.Pattern.matches($RE, $X)

  # ------------------------------------------------------------
  # D) XPath Injection: request data -> XPath.compile/evaluate(String)
  # OWASP: use XPathVariableResolver, avoid string-built XPath.
  # ------------------------------------------------------------
  - id: SPRING-OWASP-XPATH-INJECTION
    message: >
      Possible XPath injection: request-derived data reaches XPath.compile/evaluate with a dynamic expression.
      Prefer XPathVariableResolver / variable binding instead of building XPath strings.
    severity: ERROR
    languages: [java]
    mode: taint
    metadata:
      category: security
      cwe: "CWE-643"
      owasp: "A03:2021 Injection"
      confidence: high
      framework: [spring]
    paths:
      include: ["**/*.java"]
      exclude: ["**/test/**", "**/*Test.java", ".semgrep/**"]
    pattern-sources:
      - pattern: $REQ.getParameter(...)
      - pattern: |
          @RequestParam(...) $T $X
      - pattern: |
          @PathVariable(...) $T $X
    pattern-sinks:
      - pattern: $XPATH.compile($EXPR)
      - pattern: $EXPR.evaluate($DOC)
      - pattern: $EXPR.evaluate($DOC, ...)
    pattern-sanitizers:
      - pattern: java.util.regex.Pattern.matches($RE, $X)

  # ------------------------------------------------------------
  # E) Reflected XSS (Spring MVC): request data -> returned body without encoding
  # OWASP: encode/sanitize output; use OWASP Java Encoder or Spring HtmlUtils where appropriate.
  #
  # Reduced FP approach:
  # - Only triggers when request-derived data flows into a return value in a @ResponseBody method
  #   or a RestController handler returning String/ResponseEntity<String>.
  # ------------------------------------------------------------
  - id: SPRING-OWASP-XSS-REFLECTED-RAW-RESPONSE
    message: >
      Possible reflected XSS: request-derived data is returned in an HTTP response without encoding/sanitization.
      Encode (e.g., OWASP Java Encoder) or escape (e.g., Spring HtmlUtils) or sanitize HTML when HTML is intended.
    severity: ERROR
    languages: [java]
    mode: taint
    metadata:
      category: security
      cwe: "CWE-79"
      owasp: "A03:2021 Injection"
      confidence: medium
      framework: [spring-mvc, spring-boot]
    paths:
      include: ["**/*.java"]
      exclude: ["**/test/**", "**/*Test.java", ".semgrep/**"]
    pattern-sources:
      - pattern: $REQ.getParameter(...)
      - pattern: |
          @RequestParam(...) $T $X
      - pattern: |
          @PathVariable(...) $T $X
    pattern-sinks:
      # Sink 1: returning tainted string directly
      - patterns:
          - pattern-inside: |
              @ResponseBody
              $RET $M(...){ ... }
          - pattern: return $X;
      # Sink 2: ResponseEntity<String> carrying tainted data
      - pattern: org.springframework.http.ResponseEntity.ok($X)
      - pattern: org.springframework.http.ResponseEntity.status(...).body($X)
    pattern-sanitizers:
      # Common output-encoding/sanitization options (treat as sanitizers to reduce FPs)
      - pattern: org.owasp.encoder.Encode.forHtml($X)
      - pattern: org.owasp.encoder.Encode.forHtmlAttribute($X)
      - pattern: org.owasp.encoder.Encode.forJavaScript($X)
      - pattern: org.springframework.web.util.HtmlUtils.htmlEscape($X)
      - pattern: $POLICY.sanitize($X)   # OWASP Java HTML Sanitizer PolicyFactory.sanitize(...)

  # ------------------------------------------------------------
  # F) Log Injection / unsafe logging: discourage string concatenation in logger calls
  # OWASP: use parameterized logging, avoid mixing concatenation + {} templates.
  # Kept as WARNING to reduce friction; this is often noisy in legacy code.
  # ------------------------------------------------------------
  - id: SPRING-OWASP-LOG-INJECTION-CONCAT
    message: >
      Unsafe logging pattern: string concatenation inside logger call.
      Prefer parameterized logging (e.g., logger.warn("msg {}", value)) to reduce injection/confusion risks.
    severity: WARNING
    languages: [java]
    metadata:
      category: security
      cwe: "CWE-117"
      confidence: medium
      framework: [spring]
    paths:
      include: ["**/*.java"]
      exclude: ["**/test/**", "**/*Test.java", ".semgrep/**"]
    pattern-either:
      - pattern: $LOG.warn($S + $X, ...)
      - pattern: $LOG.info($S + $X, ...)
      - pattern: $LOG.error($S + $X, ...)
      - pattern: $LOG.debug($S + $X, ...)
      - pattern: $LOG.trace($S + $X, ...)

  # ------------------------------------------------------------
  # G) Mass Assignment (heuristic): binding request body directly into persistence-looking types
  # OWASP: avoid binding user input directly to domain objects; prefer DTOs or explicit allowlists.
  #
  # This is intentionally WARNING + heuristic to avoid lots of false positives.
  # You can tighten paths to your own domain packages (recommended).
  # ------------------------------------------------------------
  - id: SPRING-OWASP-MASS-ASSIGNMENT-REQUESTBODY-DOMAIN
    message: >
      Potential mass assignment risk: @RequestBody binds directly into a domain/entity-looking type.
      Prefer DTOs (only editable fields) or explicit binding allowlists via @InitBinder setAllowedFields.
    severity: WARNING
    languages: [java]
    metadata:
      category: security
      cwe: "CWE-915"
      confidence: low
      framework: [spring-mvc, spring-boot]
    paths:
      include: ["**/*.java"]
      exclude: ["**/test/**", "**/*Test.java", ".semgrep/**"]
    patterns:
      - pattern: |
          public $RET $M(..., @RequestBody $T $X, ...){ ... }
      - metavariable-regex:
          metavariable: $T
          # Heuristic: common naming conventions
          regex: ".*(Entity|Model|Domain|User|Account|Admin|Profile).*"

  # ------------------------------------------------------------
  # H) Bean Validation (best-practice): missing @Valid on request models
  # OWASP: use Jakarta Bean Validation constraints + @Valid to trigger validation at controller boundary.
  #
  # This flags only if:
  # - handler takes @RequestBody, and
  # - parameter is NOT annotated with @Valid or @Validated.
  # Kept as WARNING.
  # ------------------------------------------------------------
  - id: SPRING-OWASP-BEAN-VALIDATION-MISSING-VALID
    message: >
      Missing validation on request model: consider adding @Valid (or @Validated) and Bean Validation constraints
      to enforce allowlist-style input validation at the controller boundary.
    severity: WARNING
    languages: [java]
    metadata:
      category: security
      cwe: "CWE-20"
      confidence: medium
      framework: [spring]
    paths:
      include: ["**/*.java"]
      exclude: ["**/test/**", "**/*Test.java", ".semgrep/**"]
    patterns:
      - pattern: |
          public $RET $M(..., @RequestBody $T $X, ...){ ... }
      - pattern-not: |
          public $RET $M(..., @Valid @RequestBody $T $X, ...){ ... }
      - pattern-not: |
          public $RET $M(..., @Validated @RequestBody $T $X, ...){ ... }
